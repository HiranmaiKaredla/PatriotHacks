# -*- coding: utf-8 -*-
"""NERfromUQ.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K6y-4qDc6MrBNTuvK5R8vkYZIDdNtDyW
"""

# !pip install python-dotenv
# !pip install openai
# import getpass
import os
os.environ["OPENAI_API_KEY"] = ""

import pandas as pd
import json
from dotenv import load_dotenv

load_dotenv()  # take environment variables from .env.
from openai import OpenAI

import requests
from pprint import pprint

client = OpenAI()

# Integration Starts here
user_query = "Give all the properties in seattle with 2bhk which has parking"

list_responses = []

response = client.chat.completions.create(
  model="gpt-3.5-turbo-1106",
  response_format={ "type": "json_object" },
  messages=[
    {"role": "system", "content": 'You are a helpful assistant that extracts locations from the user query. For every query, list the locations. Use the json format in the output.'},
    {"role": "user", "content": user_query}
  ]
)
generated_content = response.choices[0].message.content
list_responses.append(generated_content)

list_of_locations = []

# Extract key values from each JSON string
for json_str in list_responses:
    # Parse JSON string to a dictionary
    json_dict = json.loads(json_str)

    # Access specific keys and print their values
    locations = json_dict.get('locations', [])
    if len(locations) > 0:
        list_of_locations.extend(locations)

# print("Locations: " + str(list_of_locations[0]))

target_location = list_of_locations[0]

## CSV Pointer to the Data
from google.colab import drive
drive.mount('/content/drive')
df = pd.read_csv("/content/drive/MyDrive/Copy of final-data.csv")
df.loc[(df['latitude'] == 41.7061) & (df['longitude'] == -70.7558), 'zip_code'] = 2738
df.loc[(df['latitude'] == 59.811) & (df['longitude'] == -139.5532), 'zip_code'] = 99689

df = df[
    df['latitude'].notnull() &
    df['longitude'].notnull() &
    df['cityname'].notnull() &
    df['price'].notnull()
].reset_index(drop=True)

df.fillna({'bathrooms': 1.5}, inplace=True)
df.fillna({'bedrooms': 2}, inplace=True)
df['zip_code'] = df['zip_code'].astype(int)

df.info()

target_df = df[df['cityname'].str.lower() == target_location.lower()]
unique_lat_lon = target_df[['latitude', 'longitude']].drop_duplicates().to_dict(orient='records')

"""### Google API Amenities, Infrastructure etc """

# Define the API endpoint and API key
url = "https://places.googleapis.com/v1/places:searchNearby"
GMAPS_API_KEY = ""

keys = ['university', 'grocery_store', 'transit_station',
        'movie_theater', 'bank', 'restaurant', 'grocery_store',
        'gym', 'hospital', 'fire_station', 'gas_station']

def get_popularity(lat, long, key):

    payload = {
    "includedTypes": [key],
    "maxResultCount": 20,
    "locationRestriction": {
        "circle": {
            "center": {
                "latitude": lat,
                "longitude": long
            },
            "radius": 1000.0
            }
        }
    }

    # Define the headers
    headers = {
        "Content-Type": "application/json",
        "X-Goog-Api-Key": GMAPS_API_KEY,
        "X-Goog-FieldMask": "places.displayName"
    }

    # Make the POST request
    response = requests.post(url, json=payload, headers=headers)
    if response.status_code == 200:
        data = response.json()
    else:
        print("Error:", response.status_code, response.text)
    try:
        return len(data['places'])
    except:
        return 0

def get_popularity_score(lat, long):
  popularity_score = {key:get_popularity(lat, long, key)/20 for key in keys}
  return sum(popularity_score.values())

for i, each in enumerate(unique_lat_lon):
  lat, lon = each['latitude'], each['longitude']
  each['popularity_score'] = get_popularity_score(lat, lon)

# Safety, Essentials, Recreation, Education, Transport
# university
# movie_theater
# bank
# restaurant
# grocery_store
# gym
# transit_station
# hospital
# fire_station
# gas_station

# Create a dictionary with (latitude, longitude) as keys and popularity_score as values
popularity_dict = {(item['latitude'], item['longitude']): item['popularity_score'] for item in unique_lat_lon}

# Function to get popularity score based on latitude and longitude
def get_popularity_score(row):
    return popularity_dict.get((row['latitude'], row['longitude']), None)  # Default to None if not found


for key, value in popularity_dict.items():
    lat, lon = key
    target_df.loc[(target_df['latitude'] == lat) & (target_df['longitude'] == lon), 'popularity_score'] = value


# Display the Popular Recommendations
target_df.sort_values(by='popularity_score', ascending=False)[:5]